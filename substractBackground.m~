function [xyz, rgb] = substractBackground(pcl)
%{
#Input
  pcl - 3D frame 
#
%}
  %select data point
  existingId = pcl(:, :, 6) ~= 0;
  
  x  = pcl(:, :, 4);
  y  = pcl(:, :, 5);
  z  = pcl(:, :, 6);
  
  x  = x(existingId);
  y  = y(existingId);
  z  = z(existingId);
  
  rgbUndistorted = pcl(:,:,1:3)/255;
  [Xim, cm] = rgb2ind(rgbUndistorted, 512);
  Xim = Xim(existingId);
  XYZ = [x y z];
  alpha = deg2rad(30);
  R = [1 0 0; 0 cos(alpha) sin(alpha); 0 -sin(alpha) cos(alpha)];
  XYZ = (R*XYZ')';
  figure (1);
  fscatter32(XYZ(:,1), XYZ(:,2), XYZ(:,3), Xim, cm)
  max_z = max(z(:));
  zlim([0.2 max(z(:))])
  ylim([0 1])
  xlim([-.5 .5])
  set(gca,'zdir','reverse')
  mean_point = mean(XYZ); % 1x3
  %centering
  point_dev = XYZ - ones(size(XYZ, 1), 1) * mean_point;
  %scatter matrix along XYZ
  scatter = point_dev' * point_dev; % 3x3
  [U,D,V]= svd(scatter);
  %background normal vector, get the vector with lowest eigenvalue
  bg_n = V(:, 3)'; %1x3
  %projection of centered cloud points on the background normal 
  %in other words how far certain point from the background
  norm_prjs = point_dev * bg_n'; % num_points x 1
  %background point project on background normal
  bg_prj_point = prctile(norm_prjs, 50);
  bg_point = mean_point + bg_prj_point * bg_n;% 1x3

  %background surface parameters for following equation:
  % n*r=d where n - normal, d - offset along the normal
  d = bg_point *  bg_n'
  threshold_raw = 0.0305;
  %threshold = 0.0125;
  cloud_surf_prjs = XYZ * bg_n'; %number of cloud point x 1
  %background indices
  %bg_ids = (cloud_surf_prjs - d) < -threshold; 
  surf_diff = cloud_surf_prjs - d;
  bg_ids_raw = abs(surf_diff) < threshold_raw; 
  %foreground indices
  fg_ids_raw = ~bg_ids_raw;
  fg_diff = surf_diff(fg_ids_raw);
  %remove noise
  threshold = 0.0125;
  norm_is_inverted = fg_diff(1) < 0;
  if norm_is_inverted
      fg_ids = (surf_diff) < -threshold; 
  else
      fg_ids = (surf_diff) > threshold;
  end
end

